/* * Dave Rosenberg * Comp 2000 - Data Structures * Lab: Queue ADT * Fall, 2019 *  * Usage restrictions: *  * You may use this code for exploration, experimentation, and furthering your * learning for this course. You may not use this code for any other * assignments, in my course or elsewhere, without explicit permission, in * advance, from myself (and the instructor of any other course). *  * Further, you may not post or otherwise share this code with anyone other than * current students in my sections of this course. Violation of these usage * restrictions will be considered a violation of the Wentworth Institute of * Technology Academic Honesty Policy. * * Do not remove this notice. */package edu.wit.dcsn.comp2000.queueadt;/** * A class that implements the ADT queue by using an expandable circular array. *  * @author Frank M. Carrano * @author Timothy M. Henry * @version 4.0 * @version 5.0 *  * @author David M Rosenberg * @version 4.1.0.0 *          <ul> *          <li>initial version based upon Carrano and Henry implementation in *          the 4th edition of the textbook *          <li>modified per assignment *          </ul> * @version 5.1.0.0 2019-07-14 *          <ul> *          <li>simplified determination of parameters to *          {@code System.arraycopy()} in {@code ensureCapacity()} *          <li>revisions to match: *          <ul> *          <li>the 5th edition of the textbook *          <li>Dave Rosenberg Company coding standard *          <li>this semester's assignment *          </ul> *          </ul> * @version 5.2.0.0 2019-10-23 revise for this semester *  * @author Sunny Lee * @version 5.3.0.0 2019-10-31 *  * @param <T> The type of all objects to store in the queue */public final class ArrayQueue<T> implements QueueInterface<T> {	// utility constants	/** default (and minimum) number of entries in a queue */	public static final int DEFAULT_CAPACITY = 3;	/** maximum number of entries in a queue */	public static final int MAX_CAPACITY = 10000;	// instance variables	private T[] queue; // Circular array of queue entries	private int frontIndex; // Index of front entry	private int backIndex; // Index of back entry	private int numberOfEntries; // number of entries 	private boolean integrityOK; // true if data structure is created									// correctly, false if corrupted	// constructors	/**	 * Initializes a queue with a default capacity	 */	public ArrayQueue() {		this(DEFAULT_CAPACITY);	} // end default constructor	/**	 * Initializes a queue with a specified capacity	 * 	 * @param initialCapacity in the range DEFAULT_CAPACITY..MAX_CAPACITY	 */	public ArrayQueue(int initialCapacity) {		this.integrityOK = false;		checkCapacity(initialCapacity);		initializeState(initialCapacity); 			} // end constructor	// public API methods	/*	 * (non-Javadoc)	 * 	 * @see edu.wit.dcsn.comp2000.queueadt.QueueInterface#clear()	 */	@Override	public void clear() {		checkIntegrity();				initializeState(queue.length); 	} // end clear()	/*	 * (non-Javadoc)	 * 	 * @see edu.wit.dcsn.comp2000.queueadt.QueueInterface#dequeue()	 */	@Override	public T dequeue() {		checkIntegrity();		if (isEmpty())			throw new EmptyQueueException();		T front = this.queue[this.frontIndex];		this.queue[this.frontIndex] = null;		this.frontIndex = (this.frontIndex + 1) % this.queue.length;		numberOfEntries--; 		return front;	} // end dequeue()	/*	 * (non-Javadoc)	 * 	 * @see edu.wit.dcsn.comp2000.queueadt.QueueInterface#enqueue(java.lang.Object)	 */	@Override	public void enqueue(T newEntry) {		checkIntegrity();		ensureCapacity();		this.backIndex = (this.backIndex + 1) % this.queue.length;		this.queue[this.backIndex] = newEntry;		numberOfEntries++; 	} // end enqueue()	/*	 * (non-Javadoc)	 * 	 * @see edu.wit.dcsn.comp2000.queueadt.QueueInterface#getFront()	 */	@Override	public T getFront() {		checkIntegrity();		if (isEmpty()) {			throw new EmptyQueueException();		}		return this.queue[this.frontIndex];	} // end getFront()	/*	 * (non-Javadoc)	 * 	 * @see edu.wit.dcsn.comp2000.queueadt.QueueInterface#isEmpty()	 */	@Override	public boolean isEmpty() {		checkIntegrity();		return numberOfEntries == 0;	} // end isEmpty()	// private utility methods	/**	 * Ensure the instance was properly initialized	 */	private void checkIntegrity() {		if (!this.integrityOK) {			throw new SecurityException("ArrayQueue object is corrupt.");		}	} // end checkIntegrity()	/**	 * Validate that the desired capacity is within acceptable limits.	 * 	 * @param desiredCapacity size in the range DEFAULT_CAPACITY..MAX_CAPACITY,	 *                        inclusive	 */	private void checkCapacity(int desiredCapacity) {		if (desiredCapacity > MAX_CAPACITY) {			throw new IllegalStateException(					"Attempt to create a queue whose capacity is too " + "large (" + desiredCapacity + ").");		}		if (desiredCapacity < DEFAULT_CAPACITY) {			throw new IllegalStateException(					"Attempt to create a queue whose capacity is too " + "small (" + desiredCapacity + ").");		}	} // end checkCapacity()	/**	 * Doubles the size of the array queue if it is full	 * 	 * <p>	 * Precondition: checkIntegrity() has been called.	 */	private void ensureCapacity() {		if (isFull()) { // If array is full, double size of array			T[] oldQueue = this.queue;			int oldSize = oldQueue.length;			int newSize = 2 * oldSize;			checkCapacity(newSize);			this.integrityOK = false;			// The cast is safe because the new array contains null entries			@SuppressWarnings("unchecked")			T[] tempQueue = (T[]) new Object[newSize];			this.queue = tempQueue;			//copy the circular array into a larger array			System.arraycopy(oldQueue, frontIndex, tempQueue, 0, oldSize - this.frontIndex); 			System.arraycopy(oldQueue, 0, tempQueue, oldSize - this.frontIndex, this.frontIndex);			this.frontIndex = 0;			this.backIndex = oldSize - 1;			this.integrityOK = true;		} // end if	} // end ensureCapacity()	/**	 * Initializes a queue with a specified capacity	 * 	 * @param desiredCapacity in the range DEFAULT_CAPACITY..MAX_CAPACITY, inclusive	 */	private void initializeState(int desiredCapacity) {		@SuppressWarnings("unchecked")		T[] tempQueue = (T[]) new Object[desiredCapacity];		this.queue = tempQueue;		this.frontIndex = 0;		this.backIndex = desiredCapacity - 1;		this.numberOfEntries = 0; 		this.integrityOK = true;			} // end initializeState()	/**	 * Determine if the queue's array is full	 * 	 * @return true if the array is full, false otherwise	 */	private boolean isFull() {		return numberOfEntries == this.queue.length; 	} // end isFull()		/**	 * 	 * @param args	 */	public static void main(String[] args)	{		ArrayQueue<Integer> arr = new ArrayQueue<>(); 				for(int i = 0; i < 50; i++)		{			arr.enqueue(i); 		}		System.out.println(arr.numberOfEntries);				for(int i = 0; i < 50; i++)		{			System.out.println(arr.getFront()); 			arr.dequeue(); 		}		System.out.println(arr.numberOfEntries);	}} // end class ArrayQueue